<?xml version="1.0" encoding="UTF-8"?>
    <!--
    This software is in the public domain under CC0 1.0 Universal plus a 
    Grant of Patent License.

    To the extent possible under law, the author(s) have dedicated all
    copyright and related and neighboring rights to this software to the
    public domain worldwide. This software is distributed without any
    warranty.

    You should have received a copy of the CC0 Public Domain Dedication
    along with this software (see the LICENSE.md file). If not, see
    <http://creativecommons.org/publicdomain/zero/1.0/>.
    -->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

    <!-- These services are based on the PayTrace API, version 1. See: http://help.paytrace.com/api -->
    <!-- REST API docs: https://developers.paytrace.com/support/home -->

    <service verb="authorize" noun="Payment">
        <implements service="mantle.account.PaymentServices.authorize#Payment"/>
        <out-parameters>
            <parameter name="paymentGatewayResponseId"/>
            <!-- <parameter name="requestMap" type="Map"/><parameter name="response" type="Map"/> -->
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment"/>
            <if condition="payment == null"><return message="Payment ${paymentId} not found"/></if>
            <set field="paymentMethod" from="payment.'mantle.account.method.PaymentMethod'"/>
            <if condition="paymentMethod?.paymentMethodTypeEnumId != 'PmtCreditCard'">
                <return error="true" message="Cannot authorize payment ${paymentId}, not a Credit Card payment."/>
            </if>
                
            <set field="creditCard" from="payment.'mantle.account.method.CreditCard'"/>
            <if condition="!cardSecurityCode"><set field="cardSecurityCode" from="creditCard?.cardSecurityCode"/></if>

            <set field="visit" from="payment.'moqui.server.Visit'"/>

            <!-- if no gatewayCimId, store the PaymentMethod on CIM -->
            <if condition="!paymentMethod.gatewayCimId">
                <service-call name="PayTrace.PayTraceVaultServices.store#CustomerPaymentMethod"
                            in-map="[paymentMethodId:paymentMethod.paymentMethodId, paymentId:paymentId, paymentGatewayConfigId:paymentGatewayConfigId]"/>
                <set field="paymentMethod" from="payment.'mantle.account.method.PaymentMethod'"/>
            </if>
            <if condition="!paymentMethod.gatewayCimId"><return message="Payment Method ${paymentMethod.paymentMethodId} has no gateway CIM ID, not processing payment"/></if>

            <entity-find-one entity-name="PayTrace.PaymentGatewayPayTrace" value-field="pgpt"/> 
            <if condition="pgpt == null"><return error="true" message="No PaymentGatewayPayTrace found with ID ${paymentGatewayConfigId}"/></if>

            <service-call name="PayTrace.PayTraceVaultPaymentServices.login#PayTrace" in-map="context" out-map="token"/>
            <set field="accessToken" from="token.token.access_token"/>

            <!-- assemble the full request Map -->
            <set field="requestMap" from="[amount:payment.amount, customer_id:paymentMethod.gatewayCimId, integrator_id:pgpt.integratorId, invoice_id:payment.orderId]"/>
            <if condition="cardSecurityCode"><set field="requestMap.csc" from="cardSecurityCode"/></if>
            <log message="PayTrace Authorize request for payment ${paymentId}:\n${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(requestMap))}"/>

            <script><![CDATA[
                org.moqui.util.RestClient restClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                    .addHeader("Authorization", "Bearer ${accessToken}")
                    .addHeader("Content-Type", "application/json").jsonObject(requestMap)

                restClient.uri().protocol("https").host(pgpt.hostName ?: "api.paytrace.com").port(443).path(pgpt.apiVersion ?: "v1")
                        .path("transactions").path("authorization").path("by_customer").build()

                org.moqui.util.RestClient.RestResponse restResponse = restClient.call()
                    
                if (restResponse.statusCode < 200 || restResponse.statusCode >= 500) {
                    ec.message.addMessage("PayTrace Authorize API error ${restResponse.statusCode}: ${restResponse.text()}")
                    return
                }
                responseMap = restResponse.jsonObject()
            ]]></script>
            <log message="PayTrace Authorize response for payment ${paymentId}:\n${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(responseMap))}"/>

            <set field="paymentOperationEnumId" value="PgoAuthorize"/>
            <service-call name="PayTrace.PayTraceVaultPaymentServices.save#Response" in-map="context" out-map="context"/>

            <!-- NOTE: only send for larger amounts? -->
            <if condition="payment.orderId &amp;&amp; creditCard.creditCardTypeEnumId in ['CctVisa', 'CctMastercard']">
                <!-- NOTE: called async for performance reasons, secondary priority to auth, and to keep errors from causing problems with the auth -->
                <service-call name="PayTrace.PayTraceVaultPaymentServices.send#LevelThreeData" async="true"
                        in-map="[paymentId:paymentId, paymentGatewayConfigId:paymentGatewayConfigId, accessToken:accessToken]"/>
            </if>
        </actions>
    </service>
    <service verb="send" noun="LevelThreeData" authenticate="anonymous-all">
        <!-- NOTE: anonymous-all so that can be called async, do not expose externally -->
        <in-parameters>
            <parameter name="paymentId" required="true"/>
            <parameter name="paymentGatewayConfigId" required="true"/>
            <parameter name="accessToken"/>
        </in-parameters>
        <out-parameters>
            <!-- <parameter name="requestMap" type="Map"/><parameter name="responseMap" type="Map"/> -->
        </out-parameters>
        <actions>
            <entity-find-one entity-name="PayTrace.PaymentGatewayPayTrace" value-field="pgpt"/>
            <if condition="pgpt == null"><return error="true" message="No PaymentGatewayPayTrace found with ID ${paymentGatewayConfigId}"/></if>

            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment"/>

            <if condition="!payment.orderId"><return/></if>

            <set field="paymentMethod" from="payment.'mantle.account.method.PaymentMethod'"/>
            <set field="paymentMethodId" from="paymentMethod.paymentMethodId"/>
            <set field="paymentRefNum" from="payment.paymentRefNum"/>
            <if condition="!paymentRefNum">
                <service-call name="mantle.account.PaymentServices.get#AuthorizePaymentGatewayResponse" in-map="context" out-map="context"/>
                <if condition="paymentGatewayResponse == null"><return type="danger" message="Could not find successful authorization for Payment ${paymentId}"/></if>
                <set field="paymentRefNum" from="paymentGatewayResponse.referenceNum"/>
            </if>
            
            <if condition="!paymentRefNum"><return type="danger" message="Could not find successful authorization for Payment ${paymentId}"/></if>
        
            <set field="creditCard" from="payment.'mantle.account.method.CreditCard'"/>
            <!-- return now if not Visa or Mastercard -->
            <if condition="!(creditCard.creditCardTypeEnumId in ['CctVisa', 'CctMastercard'])"><return/></if>

            <if condition="!accessToken">
                <service-call name="PayTrace.PayTraceVaultPaymentServices.login#PayTrace" in-map="context" out-map="token"/>
                <set field="accessToken" from="token.token.access_token"/>
            </if>

            <set field="postalAddress" from="paymentMethod.'mantle.party.contact.PostalAddress'"/>

            <!-- get tax IDs: partyIdTypeEnumId in ['PtidFein', others?] for now just PtidFein -->
            <entity-find-one entity-name="mantle.party.PartyIdentification" value-field="taxIdentCustomer">
                <field-map field-name="partyId" from="payment.fromPartyId"/>
                <field-map field-name="partyIdTypeEnumId" value="PtidFein"/>
            </entity-find-one>
            <entity-find-one entity-name="mantle.party.PartyIdentification" value-field="taxIdentVendor">
                <field-map field-name="partyId" from="payment.toPartyId"/>
                <field-map field-name="partyIdTypeEnumId" value="PtidFein"/>
            </entity-find-one>

            <set field="orderId" from="payment.orderId"/>
            <set field="orderPartSeqId" from="payment.orderPartSeqId"/>
            <service-call name="mantle.order.OrderInfoServices.get#OrderDisplayInfo" in-map="[orderId:orderId]" out-map="orderInfo"/>
            <set field="orderPartInfo" from="orderPartSeqId ? orderInfo.orderPartInfoList.find({ it.orderPart.orderPartSeqId == orderPartSeqId }) : orderInfo.orderPartInfoList.first()"/>
            
            <set field="lineItems" from="[]"/>
            <set field="orderDiscount" from="0.0"/>
            <set field="orderTaxAmount" from="0.0"/>
            <set field="freightTax" from="0.0"/>
            <set field="freightAmount" from="0.0"/>

            <iterate list="orderInfo.orderItemList" entry="orderItem">
                <if condition="orderItem.parentItemSeqId"><continue/></if>
                <if condition="orderItem.quantity == 0.0"><continue/></if>

                <service-call name="mantle.order.OrderServices.get#OrderItemTotal" out-map-add-to-existing="false"
                        in-map="[orderItem:orderItem, getChildrenTotals:true]" out-map="orderItemData"/>

                <if condition="orderItem.itemTypeEnumId == 'ItemShipping'"><then>
                    <set field="freightAmount" from="freightAmount + orderItemData.itemTotal"/>

                    <iterate list="orderItemData.childOrderItemList" entry="childOrderItem">
                        <set field="combinedQuantity" from="(childOrderItem.quantity != null ? childOrderItem.quantity : 1.0) * (childOrderItem.selectedAmount ?: 1.0)"/>
                        <set field="childItemTotal" from="(combinedQuantity * (childOrderItem.unitAmount ?: 0.0)).setScale(2, BigDecimal.ROUND_HALF_UP)"/>
                        <if condition="childOrderItem.itemTypeEnumId in ['ItemSalesTax', 'ItemVatTax']">
                            <set field="freightTax" from="orderTaxAmount + childItemTotal"/>
                        </if>
                    </iterate>
                </then><else>
                    <set field="productId" from="orderItem.productId"/>
                    <entity-find-one entity-name="mantle.product.Product" value-field="product"/>

                    <if condition="orderItem.itemTypeEnumId in ['ItemSalesTax', 'ItemVatTax']">
                        <set field="orderTaxAmount" from="orderTaxAmount + orderItemData.itemTotal"/>
                        <continue/>
                    </if>

                    <set field="taxIncluded" from="false"/>
                    <set field="quantityDiscount" from="0.0"/>
                    <set field="itemDiscount" from="0.0"/>

                    <iterate list="orderItemData.childOrderItemList" entry="childOrderItem">
                        <set field="combinedQuantity" from="(childOrderItem.quantity != null ? childOrderItem.quantity : 1.0) * (childOrderItem.selectedAmount ?: 1.0)"/>
                        <set field="childItemTotal" from="(combinedQuantity * (childOrderItem.unitAmount ?: 0.0)).setScale(2, BigDecimal.ROUND_HALF_UP)"/>

                        <if condition="childOrderItem.itemTypeEnumId in ['ItemSalesTax', 'ItemVatTax']">
                            <set field="taxIncluded" from="true"/>
                            <set field="orderTaxAmount" from="orderTaxAmount + childItemTotal"/>
                        </if>

                        <if condition="childOrderItem.itemTypeEnumId in ['ItemDiscount', 'ItemSupplierDiscount']">
                            <set field="quantityDiscount" from="quantityDiscount + childOrderItem.quantity"/>
                            <set field="itemDiscount" from="itemDiscount + childItemTotal"/>
                            <set field="orderDiscount" from="orderDiscount + childItemTotal"/>
                        </if>
                    </iterate>

                    <!--PayTrace Unit of Measure
                        see complete list at: http://help.paytrace.com/level3-unit-of-measure

                                                                PayTrace       Moqui Uom
                        Acre                                        ACR         AREA_A
                        Ampere                                      AMP         OTH_A
                        Bar                                         BAR         PRES_bar
                        Barrel (petroleum)                          BLL         VLIQ_bbl
                        British thermal unit                        BTU         EN_BTU
                        Candela                                     CDL         OTH_cd
                        Cubic centimetre                            CMQ         VDRY_cm3
                        Cubic foot                                  FTQ         VDRY_ft3
                        Cubic inch                                  INQ         VDRY_in3
                        Cubic millimetre                            MMQ         VDRY_mm3
                        Cubic yard                                  YDQ         VDRY_yd3
                        Day                                         DAY         TF_day
                        Decade (ten years)                          DEC         TF_decade
                        Degree Celsius                              CEL         TEMP_C
                        Degree Fahrenheit                           FAH         TEMP_F
                        Fluid ounce (28,413 cm3)                    OZI         VLIQ_ozUK
                        Fluid ounce (29,5735 cm3)                   OZA         VLIQ_ozUS
                        Foot (0,3048 m)                             FOT         LEN_ft
                        Gill (0,142065 dm3)                         GII         VLIQ_gi
                        Grain GB, US (64,798910 mg)                 GRN         WT_gr
                        Gram                                        GRM         WT_g
                        Hectare                                     HAR         AREA_ha
                        Hour                                        HUR         TF_hr
                        Inch (25,4 mm)                              INH         LEN_in
                        Joule                                       JOU         EN_J
                        Kelvin                                      KEL         TEMP_K
                        Kilogram per cubic meter                    KMQ         DENS_kg_m3
                        Kilogram                                    KGM         WT_kg
                        Kilopascal                                  KPA         PRES_kPa
                        Kilowatt                                    KWT         PW_kw
                        Kilowatt-hour                               KWH         EN_kw_h
                        Knot (1 nautical mile per hour)             KNT         VEL_kn
                        Liquid gallon (3,78541 dm3)                 GLL         VLIQ_galUS
                        Liquid pint (0,473176 dm3)                  PTL         VLIQ_ptUS
                        Liquid quart (0,946353 dm3)                 QTL         VLIQ_qt
                        Litre (1 dm3)                               LTR         VLIQ_L
                        Long ton GB, US (1,0160469 t)               LTN         WT_lt
                        Metre per second                            MTS         not found
                        Metre                                       MTR         LEN_m
                        Metric ton (1000 kg)                        TNE         WT_mt
                        Millibar                                    MBR         PRES_mbar
                        Milligram                                   MGM         WT_mg
                        Minute                                      MIN         TF_min
                        Month                                       MON         TF_mon
                        Nautical mile (1852 m)                      NMI         LEN_nmi
                        Ounce GB, US (28,349523 g)                  ONZ         WT_oz
                        Pascal                                      PAL         PRES_Pa
                        Pennyweight GB, US (1555174 g)              DWT         WT_dwt
                        Piece                                       PCE         OTH_ea, OTH_ct
                        Pound GB, US (0,45359237 kg)                LBR         WT_lb
                        Quart (1,136523 dm3)                        QTI         VLIQ_qt
                        Revolution per minute                       RPM         OTH_RPM
                        Score                                       SCO         TF_score
                        Second                                      SEC         TF_s
                        Short ton GB, US (0,90718474 t)             STN         WT_sh_t
                        Square centimetre                           CMK         AREA_cm2
                        Square foot                                 FTK         AREA_ft2
                        Square inch                                 INK         AREA_in2
                        Square kilometre                            KMK         AREA_km2
                        Square metre                                MTK         AREA_m2
                        Square mile                                 MIK         AREA_mi2
                        Square millimetre                           MMK         AREA_mm2
                        Square yard                                 YDK         AREA_yd2
                        standard atmosphere (101325 Pa)             ATM         PRES_atm
                        (statute) mile (1609,344 m)                 SMI         LEN_mi
                        Stone GB (6,350293 kg)                      STI         WT_st
                        Technical atmosphere (98066,5 Pa)           ATT         PRES_at
                        Troy ounce                                  APZ         WT_oz_tr
                        Watt                                        WTT         PW_w
                        Week                                        WEE         TF_wk
                        Yard (0,9144 m)                             YRD         LEN_yd
                        Year                                        ANN         TF_yr
                    -->

                    <set field="unitMeasureMap" from="[AREA_A:'ACR', OTH_A:'AMP',
                        PRES_bar:'BAR',VLIQ_bbl:'BLL', EN_BTU:'BTU', OTH_cd:'CDL', VDRY_cm3:'CMQ',
                        VDRY_ft3:'FTQ', VDRY_in3:'INQ', VDRY_mm3:'MMQ', VDRY_yd3:'YDQ', TF_day:'DAY',
                        TF_decade:'DEC', TEMP_C:'CEL', TEMP_F:'FAH', VLIQ_ozUK:'OZI',
                        VLIQ_ozUS:'OZA', LEN_ft:'FOT', VLIQ_gi:'GII', WT_gr:'GRN',
                        WT_g:'GRM', AREA_ha:'HAR', TF_hr:'HUR', LEN_in:'INH', EN_J:'JOU', TEMP_K:'KEL',
                        DENS_kg_m3:'KMQ', WT_kg:'KGM', PRES_kPa:'KPA', PW_kw:'KWT', EN_kw_h:'KWH',
                        VEL_kn:'KNT', VLIQ_galUS:'GLL', VLIQ_ptUS:'PTL', VLIQ_qt:'QTL', VLIQ_L:'LTR', WT_lt:'LTN', LEN_m:'MTR',
                        WT_mt:'TNE', PRES_mbar:'MBR', WT_mg:'MGM', TF_min:'MIN', TF_mon:'MON', LEN_nmi:'NMI',
                        WT_oz:'ONZ', PRES_Pa:'PAL', WT_dwt:'DWT', OTH_ea:'PCE', OTH_ct:'PCE',
                        WT_lb:'LBR', OTH_RPM:'RPM', TF_score:'SCO',
                        TF_s:'SEC', WT_sh_t:'STN', AREA_cm2:'CMK', AREA_ft2:'FTK', AREA_in2:'INK',
                        AREA_km2:'KMK', AREA_m2:'MTK', AREA_mi2:'MIK', AREA_mm2:'MMK', AREA_yd2:'YDK',
                        PRES_atm:'ATM', LEN_mi:'SMI', WT_st:'STI', PRES_at:'ATT', WT_oz_tr:'APZ', PW_w:'WTT',
                        TF_wk:'WEE', LEN_yd:'YRD', TF_yr:'ANN']"/>

                    <set field="unitMeasure" from="unitMeasureMap.get(product.amountUomId) ?: 'PCE'"/>

                    <if condition="creditCard.creditCardTypeEnumId == 'CctVisa'">
                        <!--Missing to find in line item data Visa
                            additional_tax_amount         has not been used yet
                            additional_tax_rate           has not been used yet
                            commodity_code                for now it is ignored
                        -->

                        <if condition="orderItemData.itemPlusChildrenTotal &gt;= 0.0">
                            <set field="item" from="[amount: orderItemData.itemPlusChildrenTotal,
                                description: orderItem.itemDescription?.take(35), product_id: orderItem.productId,
                                quantity: (orderItem.quantity ?: 1.0), unit_of_measure: (unitMeasure ?: 'PCE'),
                                unit_cost: (orderItem.unitAmount ?: 0.0), discount_amount: itemDiscount.abs()]"/>
                        </if>
                    </if>
                    <if condition="creditCard.creditCardTypeEnumId == 'CctMastercard'">
                        <!--Missing to find in line item data Mastercard
                            additional_tax_amount         has not been used yet
                            additional_tax_included       has not been used yet
                            additional_tax_rate           has not been used yet
                        -->

                        <set field="item" from="[amount: orderItemData.itemPlusChildrenTotal,
                            description:orderItem.itemDescription?.take(35),
                            discount_amount: itemDiscount.abs(), discount_included: (quantityDiscount &gt; 0.0),
                            discount_rate: itemDiscount.abs().multiply(100.0).divide(orderItemData.itemTotal, 2, BigDecimal.ROUND_HALF_UP),
                            debit_or_credit: (orderItemData.itemPlusChildrenTotal &lt; 0.0 ? 'C' : 'D'),
                            merchant_tax_id: taxIdentVendor?.idValue, product_id: orderItem.productId,
                            quantity: (orderItem.quantity ?: 1.0),
                            tax_included:taxIncluded,
                            unit_cost: (orderItem.unitAmount ?: 0.0),
                            unit_of_measure: unitMeasure ?: 'PCE']"/>
                    </if>

                    <script>lineItems.add(item)</script>
                </else></if>
            </iterate>

            <if condition="creditCard.creditCardTypeEnumId == 'CctVisa'">
                <!--Visa Data
                    national_tax_amount          for now it is ignored
                    commodity_code               not yet supported, may have to be specific to the payment processor and by product
                    duty_amount                  for now it is ignored
                -->
                <!-- assemble the full request Map -->
                <set field="requestMap" from="[transaction_id:paymentRefNum, invoice_id:orderId,
                    customer_reference_id:orderPartInfo.orderPart.otherPartyOrderId,
                    tax_amount: (orderTaxAmount == 0.0 ? -1 : orderTaxAmount),
                    merchant_tax_id:taxIdentVendor?.idValue, customer_tax_id: taxIdentCustomer?.idValue,
                    discount_amount:orderDiscount.abs(),
                    freight_amount:freightAmount, additional_tax_amount:freightTax,
                    additional_tax_rate: (freightTax.abs().multiply(100.0).divide(freightAmount, 2, BigDecimal.ROUND_HALF_UP)),
                    source_address:[zip:postalAddress.postalCode],
                    shipping_address:[zip:orderPartInfo.postalAddress?.postalCode, country:orderPartInfo.postalAddress?.countryGeoId],
                    line_items:lineItems]"/>
                <set field="typePath" value="visa"/>
            </if>

            <if condition="creditCard.creditCardTypeEnumId == 'CctMastercard'">
                <!--Mastercard Data
                    national_tax_amount          for now it is ignored
                    duty_amount                  for now it is ignored
                -->
                <!-- assemble the full request Map -->
                <set field="requestMap" from="[transaction_id:paymentRefNum, invoice_id:orderId,
                    customer_reference_id:orderPartInfo.orderPart.otherPartyOrderId,
                    tax_amount: (orderTaxAmount == 0.0 ? -1 : orderTaxAmount),
                    freight_amount:freightAmount, additional_tax_amount:freightTax, additional_tax_included:(freightTax &gt; 0.0),
                    source_address:[zip:postalAddress.postalCode],
                    shipping_address:[zip:orderPartInfo.postalAddress?.postalCode, country:orderPartInfo.postalAddress?.countryGeoId],
                    line_items:lineItems]"/>
                <set field="typePath" value="mastercard"/>
            </if>

            <if condition="!typePath"><return message="the type of card is not a mastercard or visa. the level 3 data transaction will not continue"/></if>

            <log message="PayTrace Level 3 data for payment ${paymentId}:\n${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(requestMap))}"/>

            <script><![CDATA[
                org.moqui.util.RestClient restClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                        .addHeader("Authorization", "Bearer ${accessToken}")
                        .addHeader("Content-Type", "application/json").jsonObject(requestMap)
                restClient.uri().protocol("https").host(pgpt.hostName ?: "api.paytrace.com").port(443).path(pgpt.apiVersion ?: "v1")
                        .path("level_three").path(typePath).build()

                org.moqui.util.RestClient.RestResponse restResponse = restClient.call()
                    
                if (restResponse.statusCode < 200 || restResponse.statusCode >= 500) {
                    ec.message.addMessage("PayTrace Level 3 API error ${restResponse.statusCode}: ${restResponse.text()}")
                    return
                }

                responseMap = restResponse.jsonObject()
            ]]></script>
            <log message="PayTrace Level 3 response for payment ${paymentId}:\n${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(responseMap))}"/>

            <set field="paymentOperationEnumId" value="PgoLevel3Data"/>
            <service-call name="PayTrace.PayTraceVaultPaymentServices.save#Response" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="capture" noun="Payment">
        <implements service="mantle.account.PaymentServices.capture#Payment"/>
        <actions>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment"/>
            <if condition="payment == null"><return message="Payment ${paymentId} not found"/></if>
            <set field="paymentMethod" from="payment.'mantle.account.method.PaymentMethod'"/>
            <if condition="paymentMethod?.paymentMethodTypeEnumId != 'PmtCreditCard'">
                <return error="true" message="Cannot capture payment ${paymentId}, not a Credit Card payment."/>
            </if>

            <!-- if no gatewayCimId, store the PaymentMethod on CIM -->
            <if condition="!paymentMethod.gatewayCimId">
                <service-call name="PayTrace.PayTraceVaultServices.store#CustomerPaymentMethod" in-map="[paymentMethodId:paymentMethod.paymentMethodId, paymentId:paymentId, paymentGatewayConfigId:paymentGatewayConfigId]"/>
                <set field="paymentMethod" from="payment.'mantle.account.method.PaymentMethod'"/>
            </if>
            <if condition="!paymentMethod.gatewayCimId"><return message="Payment Method ${paymentMethod.paymentMethodId} has no gateway CIM ID, not processing payment"/></if>

            <set field="paymentRefNum" from="payment.paymentRefNum"/>
            <if condition="!paymentRefNum">
                <service-call name="mantle.account.PaymentServices.get#AuthorizePaymentGatewayResponse" in-map="context" out-map="context"/>
                <if condition="paymentGatewayResponse == null"><return error="true" message="Could not find successful authorization for Payment ${paymentId}"/></if>
                <set field="paymentRefNum" from="paymentGatewayResponse.referenceNum"/>
            </if>
            <if condition="!paymentRefNum"><return error="true" message="Could not find authorization transaction ID (reference number) for Payment ${paymentId}"/></if>
                
            <!-- assemble the full request Map -->
            <set field="requestMap" from="[transaction_id:paymentRefNum]"/>

            <entity-find-one entity-name="PayTrace.PaymentGatewayPayTrace" value-field="pgpt"/> 
            <if condition="pgpt == null"><return error="true" message="No PaymentGatewayPayTrace found with ID ${paymentGatewayConfigId}"/></if>

            <service-call name="PayTrace.PayTraceVaultPaymentServices.login#PayTrace" in-map="context" out-map="token"/>
                
            <script><![CDATA[
                org.moqui.util.RestClient restClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                        .addHeader("Authorization", "Bearer ${token.token.access_token}")
                        .addHeader("Content-Type", "application/json").jsonObject(requestMap)
                restClient.uri().protocol("https").host(pgpt.hostName ?: "api.paytrace.com").port(443).path(pgpt.apiVersion ?: "v1")
                        .path("transactions").path("authorization").path("capture").build()
                org.moqui.util.RestClient.RestResponse restResponse = restClient.call()
                    
                if (restResponse.statusCode < 200 || restResponse.statusCode >= 500) {
                    ec.message.addMessage("PayTrace Capture API error ${restResponse.statusCode}: ${restResponse.text()}")
                    return
                }
                responseMap = restResponse.jsonObject()
            ]]></script>
            <log message="PayTrace Capture response for payment ${paymentId}:\n${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(responseMap))}"/>

            <set field="paymentOperationEnumId" value="PgoCapture"/>
            <service-call name="PayTrace.PayTraceVaultPaymentServices.save#Response" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="authorizeAndCapture" noun="Payment">
        <description>
            This service is an alternative to the authorize and capture services, doing both in asingle operation.
            If used should generally be configured as the Paytrace service with no capture service set.
        </description>
        <implements service="mantle.account.PaymentServices.authorize#Payment"/>
        <out-parameters>
            <parameter name="responseMap" type="Map"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment"/>
            <if condition="payment == null"><return message="Payment ${paymentId} not found"/></if>
            <set field="paymentMethod" from="payment.'mantle.account.method.PaymentMethod'"/>
            <if condition="paymentMethod?.paymentMethodTypeEnumId != 'PmtCreditCard'">
                <return error="true" message="Cannot authorize and capture payment ${paymentId}, not a Credit Card payment."/>
            </if>

            <!-- if no gatewayCimId, store the PaymentMethod on CIM -->
            <if condition="!paymentMethod.gatewayCimId">
                <service-call name="PayTrace.PayTraceVaultServices.store#CustomerPaymentMethod"
                            in-map="[paymentMethodId:paymentMethod.paymentMethodId, paymentId:paymentId, paymentGatewayConfigId:paymentGatewayConfigId]"/>
                <set field="paymentMethod" from="payment.'mantle.account.method.PaymentMethod'"/>
            </if>
            <if condition="!paymentMethod.gatewayCimId"><return message="Payment Method ${paymentMethod.paymentMethodId} has no gateway CIM ID, not processing payment"/></if>

            <if condition="!cardSecurityCode">
                <set field="creditCard" from="payment.'mantle.account.method.CreditCard'"/>
                <set field="cardSecurityCode" from="creditCard?.cardSecurityCode"/>
            </if>

            <entity-find-one entity-name="PayTrace.PaymentGatewayPayTrace" value-field="pgpt"/> 
            <if condition="pgpt == null"><return error="true" message="No PaymentGatewayPayTrace found with ID ${paymentGatewayConfigId}"/></if>

            <service-call name="PayTrace.PayTraceVaultPaymentServices.login#PayTrace" in-map="context" out-map="token"/>

            <!-- assemble the full request Map -->
            <set field="requestMap" from="[amount:payment.amount, customer_id:paymentMethod.gatewayCimId, integrator_id:pgpt.integratorId, invoice_id:payment.orderId]"/>
            <log message="PayTrace Auth and Capture request for payment ${paymentId}:\n${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(requestMap))}"/>
            <if condition="cardSecurityCode"><set field="requestMap.csc" from="cardSecurityCode"/></if>

            <script><![CDATA[
                org.moqui.util.RestClient restClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                        .addHeader("Authorization", "Bearer ${token.token.access_token}")
                        .addHeader("Content-Type", "application/json").jsonObject(requestMap)
                restClient.uri().protocol("https").host(pgpt.hostName ?: "api.paytrace.com").port(443).path(pgpt.apiVersion ?: "v1")
                        .path("transactions").path("sale").path("by_customer").build()
                org.moqui.util.RestClient.RestResponse restResponse = restClient.call()
                    
                if (restResponse.statusCode < 200 || restResponse.statusCode >= 500) {
                    ec.message.addMessage("PayTrace Auth and Capture API error ${restResponse.statusCode}: ${restResponse.text()}")
                    return
                }
                responseMap = restResponse.jsonObject()
            ]]></script>
            <log message="PayTrace Auth and Capture response for payment ${paymentId}:\n${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(responseMap))}"/>

            <set field="paymentOperationEnumId" value="PgoAuthAndCapture"/>
            <service-call name="PayTrace.PayTraceVaultPaymentServices.save#Response" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="refund" noun="Payment">
        <implements service="mantle.account.PaymentServices.refund#Payment"/>
        <actions>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment"/>
            <if condition="payment == null"><return message="Payment ${paymentId} not found"/></if>
            <set field="paymentMethod" from="payment.'mantle.account.method.PaymentMethod'"/>
            <if condition="paymentMethod?.paymentMethodTypeEnumId != 'PmtCreditCard'">
                <return error="true" message="Cannot authorize and capture payment ${paymentId}, not a Credit Card payment."/>
            </if>

            <if condition="!cardSecurityCode">
                <set field="creditCard" from="payment.'mantle.account.method.CreditCard'"/>
                <set field="cardSecurityCode" from="creditCard?.cardSecurityCode"/>
            </if>
                
            <if condition="!paymentMethod.gatewayCimId"><return message="Payment Method ${paymentMethod.paymentMethodId} has no gateway CIM ID, not processing payment"/></if>

            <!-- assemble the full request Map -->
            <set field="requestMap" from="[amount:payment.amount, customer_id: paymentMethod.gatewayCimId]"/>

            <entity-find-one entity-name="PayTrace.PaymentGatewayPayTrace" value-field="pgpt"/> 
            <if condition="pgpt == null"><return error="true" message="No PaymentGatewayPayTrace found with ID ${paymentGatewayConfigId}"/></if>

            <service-call name="PayTrace.PayTraceVaultPaymentServices.login#PayTrace" in-map="context" out-map="token"/>

            <script><![CDATA[
                org.moqui.util.RestClient restClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                        .addHeader("Authorization", "Bearer ${token.token.access_token}")
                        .addHeader("Content-Type", "application/json").jsonObject(requestMap)
                restClient.uri().protocol("https").host(pgpt.hostName ?: "api.paytrace.com").port(443).path(pgpt.apiVersion ?: "v1")
                        .path("transactions").path("refund").path("to_customer").build()
                org.moqui.util.RestClient.RestResponse restResponse = restClient.call()
                    
                if (restResponse.statusCode < 200 || restResponse.statusCode >= 500) {
                    ec.message.addMessage("PayTrace Refund API error ${restResponse.statusCode}: ${restResponse.text()}")
                    return
                }
                responseMap = restResponse.jsonObject()
            ]]></script>
            <log message="PayTrace Refund response for payment ${paymentId}:\n${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(responseMap))}"/>

            <set field="paymentOperationEnumId" value="PgoRefund"/>
            <service-call name="PayTrace.PayTraceVaultPaymentServices.save#Response" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="release" noun="Payment">
        <implements service="mantle.account.PaymentServices.release#Payment"/>
        <actions>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment"/>
            <if condition="payment == null"><return message="Payment ${paymentId} not found"/></if>
            <set field="paymentMethod" from="payment.'mantle.account.method.PaymentMethod'"/>
            <if condition="paymentMethod?.paymentMethodTypeEnumId != 'PmtCreditCard'">
                <return error="true" message="Cannot release authorization for payment ${paymentId}, not a Credit Card payment."/>
            </if>
            <!-- if no gatewayCimId, store the PaymentMethod on CIM -->
            <if condition="!paymentMethod.gatewayCimId">
                <service-call name="PayTrace.PayTraceVaultServices.store#CustomerPaymentMethod"
                            in-map="[paymentMethodId:paymentMethod.paymentMethodId, paymentId:paymentId, paymentGatewayConfigId:paymentGatewayConfigId]"/>
                <set field="paymentMethod" from="payment.'mantle.account.method.PaymentMethod'"/>
            </if>
            <if condition="!paymentMethod.gatewayCimId"><return message="Payment Method ${paymentMethod.paymentMethodId} has no gateway CIM ID, not processing payment"/></if>
 
            <entity-find-one entity-name="PayTrace.PaymentGatewayPayTrace" value-field="pgpt"/> 
            <if condition="pgpt == null"><return error="true" message="No PaymentGatewayPayTrace found with ID ${paymentGatewayConfigId}"/></if>

            <set field="paymentRefNum" from="payment.paymentRefNum"/>
            <if condition="!paymentRefNum">
                <service-call name="mantle.account.PaymentServices.get#AuthorizePaymentGatewayResponse" in-map="context" out-map="context"/>
                <if condition="!paymentGatewayResponse"><return error="true" message="Could not find successful authorization for Payment ${paymentId}"/></if>
                <set field="paymentRefNum" from="paymentGatewayResponse.referenceNum"/>
            </if>
            <if condition="!paymentRefNum"><return error="true" message="Could not find authorization transaction ID (reference number) for Payment ${paymentId}"/></if>
                
            <!-- assemble the full request Map -->
            <set field="requestMap" from="[transaction_id:paymentRefNum]"/>

            <service-call name="PayTrace.PayTraceVaultPaymentServices.login#PayTrace" in-map="context" out-map="token"/>

            <script><![CDATA[
                org.moqui.util.RestClient restClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                        .addHeader("Authorization", "Bearer ${token.token.access_token}")
                        .addHeader("Content-Type", "application/json").jsonObject(requestMap)
                restClient.uri().protocol("https").host(pgpt.hostName ?: "api.paytrace.com").port(443).path(pgpt.apiVersion ?: "v1")
                        .path("transactions").path("void").build()
                org.moqui.util.RestClient.RestResponse restResponse = restClient.call()
                    
                if (restResponse.statusCode < 200 || restResponse.statusCode >= 500) {
                    ec.message.addMessage("PayTrace Release API error ${restResponse.statusCode}: ${restResponse.text()}")
                    return
                }
                responseMap = restResponse.jsonObject()
            ]]></script>
            <log message="PayTrace Level 3 response for payment ${paymentId}:\n${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(responseMap))}"/>

            <set field="paymentOperationEnumId" value="PgoRelease"/>
            <service-call name="PayTrace.PayTraceVaultPaymentServices.save#Response" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="get" noun="PaymentGatewayDetails">
        <implements service="mantle.account.PaymentServices.get#PaymentGatewayDetails"/>
        <out-parameters>
            <parameter name="transactionStatus"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment"/>
            <if condition="payment == null"><return message="Payment ${paymentId} not found"/></if>
            <set field="paymentMethod" from="payment.'mantle.account.method.PaymentMethod'"/>
            <if condition="paymentMethod?.paymentMethodTypeEnumId != 'PmtCreditCard'">
                <return message="Cannot get transaction details for payment ${paymentId}, not a Credit Card payment."/>
            </if>

            <entity-find-one entity-name="PayTrace.PaymentGatewayPayTrace" value-field="pgpt"/> 
            <if condition="pgpt == null"><return error="true" message="No PaymentGatewayPayTrace found with ID ${paymentGatewayConfigId}"/></if>

            <set field="referenceNum" from="payment.paymentRefNum"/>
            <if condition="!referenceNum">
                <service-call name="mantle.account.PaymentServices.get#AuthorizePaymentGatewayResponse" in-map="context" out-map="context"/>
                <set field="referenceNum" from="paymentGatewayResponse?.referenceNum"/>
            </if>
            <if condition="!referenceNum"><return message="Could not find transaction ID (reference number) for Payment ${paymentId}"/></if>

            <set field="paymentOperationEnumId" value="PgoTxDetails"/>
                
            <!-- assemble the full request Map -->
            <set field="requestMap" from="[transaction_id:referenceNum]"/>

            <service-call name="PayTrace.PayTraceVaultPaymentServices.login#PayTrace" in-map="context" out-map="token"/>

            <script><![CDATA[
                org.moqui.util.RestClient restClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                        .addHeader("Authorization", "Bearer ${token.token.access_token}")
                        .addHeader("Content-Type", "application/json").jsonObject(requestMap)
                restClient.uri().protocol("https").host(pgpt.hostName ?: "api.paytrace.com").port(443).path(pgpt.apiVersion ?: "v1")
                        .path("transactions").path("export").path("by_id").build()
                org.moqui.util.RestClient.RestResponse restResponse = restClient.call()
                    
                if (restResponse.statusCode < 200 || restResponse.statusCode >= 500) {
                    ec.message.addMessage("PayTrace Transaction Status API error ${restResponse.statusCode}: ${restResponse.text()}")
                    return
                }
                responseMap = restResponse.jsonObject()
            ]]></script>
            <log message="PayTrace Transaction Status response for payment ${paymentId}:\n${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(responseMap))}"/>

            <!-- PayTrace transactionType values and corresponding Payment statusId to determine needed action:
            
                SALE           PmntDelivered
                AUTHORIZATION  PmntAuthorized
                REFUND         PmntConfirmed 
                VOID           PmntVoid
                CAPTURE        PmntDelivered
                FORCESALE      PmntDelivered
                SETTLED        PmntConfirmed 
                PENDING        PmntDelivered
                DECLINED       PmntDeclined
                -->
                
            <set field="transactionStatus" from="responseMap.transaction_type"/>
            <if condition="transactionStatus">
                <set field="payTraceStatusMap" from="[AUTHORIZATION:'PmntAuthorized', 
                    REFUND:'PmntConfirmed', SALE:'PmntDelivered',FORCESALE:'PmntDelivered',  
                    CAPTURE:'PmntDelivered', SETTLED:'PmntConfirmed', PENDING:'PmntDelivered',
                    DECLINED:'PmntDeclined', VOID:'PmntVoid']"/>
                <set field="gatewayStatusId" from="payTraceStatusMap.get(transactionStatus.trim())"/>
            </if>

            <set field="referenceNum" from="responseMap.transactions?.transaction_id"/>

            <if condition="!gatewayStatusId || gatewayStatusId != payment.statusId">
                <!-- save PaymentGatewayResponse including transaction status -->
                <set field="responseCode" from="responseMap.success"/>
                <set field="reasonCode" from="responseMap.transactions?.approval_code"/>
                <set field="reasonMessage" from="responseMap.transactions.approval_message"/>
                <set field="statusCode" from="responseMap.transactions?.status_code"/>

                <service-call name="create#mantle.account.method.PaymentGatewayResponse" out-map="context"
                        in-map="[paymentGatewayConfigId:paymentGatewayConfigId, paymentOperationEnumId:paymentOperationEnumId, 
                        paymentId:payment.paymentId, paymentMethodId:payment.paymentMethodId, referenceNum:referenceNum, 
                        amount:payment.amount, amountUomId:payment.amountUomId, transactionDate:ec.user.nowTimestamp, 
                        responseCode:responseCode, reasonCode:reasonCode, reasonMessage:reasonMessage,
                        resultError:(responseCode ? 'N' : 'Y'), resultDeclined:(statusCode == 'N' ? 'Y' : 'N'), transactionStatus:transactionStatus]"/>
            </if>
        </actions>      
    </service>

    <service verb="save" noun="Response">
        <in-parameters>
            <parameter name="paymentId"/>
            <parameter name="paymentMethodId"/>
            <parameter name="paymentGatewayConfigId"/>
            <parameter name="paymentOperationEnumId" required="true"/>
            <parameter name="responseMap" type="Map" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="paymentGatewayResponseId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment"/>
            <if condition="payment &amp;&amp; !paymentMethodId"><set field="paymentMethodId" from="payment.paymentMethodId"/></if>

            <set field="responseCode" from="responseMap.success"/>
            <set field="approvalCode" from="responseMap.approval_code"/>
            <set field="avsResult" from="responseMap.avs_response"/>
            <set field="cvResult" from="responseMap.csc_response"/>
            <set field="reasonCode" from="responseMap.response_code"/>
            <set field="reasonMessage" from="responseMap.status_message"/>
            <set field="referenceNum" from="responseMap.transaction_id ?: payment?.paymentRefNum"/>

            <set field="errors" from="responseMap.errors"/>
            <set field="badCardNumber" from="errors?.'35'"/>
            <set field="badExpireMonth" from="errors?.'43'"/>
            <set field="badExpireYear" from="errors?.'44'"/>

            <!-- add other messages to reasonMessage -->
            <if condition="responseMap.approval_message"><set field="reasonMessage" from="reasonMessage + ' ' + responseMap.approval_message"/></if>
            <iterate list="errors" key="errorCode" entry="errorList">
                <set field="reasonMessage" value="${reasonMessage} (${errorCode}) ${errorList?.join(' ')}"/></iterate>
            <set field="reasonMessage" from="reasonMessage.take(255)"/>

            <service-call name="create#mantle.account.method.PaymentGatewayResponse" out-map="context"
                in-map="[paymentGatewayConfigId:paymentGatewayConfigId, paymentOperationEnumId:paymentOperationEnumId, 
                    paymentId:paymentId, paymentMethodId:paymentMethodId,
                    amount:payment.amount, amountUomId:payment?.amountUomId, referenceNum:referenceNum,
                    approvalCode:approvalCode, responseCode:responseCode,
                    reasonCode:reasonCode, reasonMessage:reasonMessage,
                    avsResult:avsResult, cvResult:cvResult,
                    transactionDate:ec.user.nowTimestamp,
                    resultSuccess:(reasonCode in [101, 106, 108, 109, 112, 120, 122, 124] ? 'Y' : 'N'),
                    resultDeclined:(reasonCode in [102, 103, 107, 110, 113, 125] ? 'Y' : 'N'),
                    resultError:(reasonCode == 1 ? 'Y' : 'N'),
                    resultBadExpire:(badExpireMonth || badExpireYear ? 'Y' : 'N'),
                    resultBadCardNumber:(badCardNumber ? 'Y' : 'N')]"/>
        </actions>
    </service>

    <service verb="login" noun="PayTrace">
        <in-parameters><parameter name="paymentGatewayConfigId"/></in-parameters>
        <out-parameters><parameter name="token" type="Map"/></out-parameters>
        <actions>
            <entity-find-one entity-name="PayTrace.PaymentGatewayPayTrace" value-field="pgpt"/> 
            <if condition="pgpt == null"><return error="true" message="No PaymentGatewayPayTrace found with ID ${paymentGatewayConfigId}"/></if>

            <!-- assemble the full request Map -->
            <set field="requestMap" from="[grant_type:'password',username:pgpt.username,password:pgpt.password]"/>
            <script><![CDATA[
                org.moqui.util.RestClient restClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                        .addHeader("Content-Type", "application/json").jsonObject(requestMap)
                restClient.uri().protocol("https").host(pgpt.hostName ?: "api.paytrace.com").port(443)
                        .path("oauth").path("token").build()
                org.moqui.util.RestClient.RestResponse restResponse = restClient.call()
                    
                if (restResponse.statusCode < 200 || restResponse.statusCode >= 500) {
                    ec.logger.error("PayTrace API response ${restResponse.statusCode}")
                    ec.message.addMessage("PayTrace API error")
                    return
                }
                token = restResponse.jsonObject()
            ]]></script> 
        </actions>
    </service>
</services>
